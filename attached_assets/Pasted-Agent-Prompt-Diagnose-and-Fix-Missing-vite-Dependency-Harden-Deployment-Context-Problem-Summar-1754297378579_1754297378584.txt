Agent Prompt: Diagnose and Fix Missing vite Dependency & Harden Deployment

Context / Problem Summary:
The GitHub Actions pipeline “Deploy Klario to Production” is failing in the build-and-deploy job because the built application (dist/index.js) is trying to import vite at runtime and cannot find it, causing ERR_MODULE_NOT_FOUND and preventing the container from starting. As a result, the health check fails with connection refused. There is also inconsistency between health endpoint paths used in different stages (/api/health vs /health).

Objectives:

Identify and eliminate the runtime dependency on vite, unless absolutely necessary.

Ensure the app build is production-ready and self-contained (no build-tool imports leaking into runtime).

Align health endpoint usage across test and deploy jobs.

Temporarily patch the CI to unblock deployment if needed, without hiding root causes.

Update internal documentation so future contributors understand the issue, the correct build expectations, and how to avoid/regress it.

Tasks (in order):

Reproduce locally:

Run the exact sequence used in CI: npm ci, npm run build, then NODE_ENV=production node dist/index.js.

Capture the stack trace and confirm it fails trying to import vite.

Root cause analysis:

Search the source tree for any imports or dynamic requires referencing vite (e.g., import ... from 'vite', usage of Vite APIs, dev-only tooling included inadvertently).

Determine whether the reference is:

Meant only for development and should be gated out in production.

Accidentally bundled/left in due to build misconfiguration.

A genuine runtime need (if so, justify why and document it).

Fix the underlying issue:

If vite is being pulled into production code by mistake:

Refactor so runtime code no longer depends on vite.

Wrap any dev-only logic with guards like if (process.env.NODE_ENV !== 'production') and ensure build tooling strips it in production.

Consider bundling the server code (using esbuild/tsup/webpack) to prevent accidental unresolved imports and produce a deterministic single output.

If skipping the refactor for immediate unblock, temporarily move vite into dependencies (not devDependencies) with a comment/ticket tracking that this is a stop-gap.

Health endpoint alignment:

Confirm what the canonical health check URL is in production (e.g., /health vs /api/health).

Update the test script(s) so both the test job and container health check hit the same, correct endpoint.

Document that endpoint consistently.

Validate changes:

Rebuild and run locally in production mode to ensure no vite error.

Build Docker image, run container, and hit the health endpoint to confirm successful startup.

Push to a branch and let the GitHub Actions pipeline run; verify build-and-deploy succeeds and health check passes.

Documentation:

Update the project README or deployment docs to include:

Expected build process and what should (and must not) be bundled into production.

The canonical health endpoint and how health checks are performed in CI/deploy.

Explanation of the previous failure mode and how it was fixed, so future regressions are easier to diagnose.

A note about temporary workaround if vite was added to dependencies, including a TODO to remove it once the proper refactor is complete.

Optional improvements (recommend as follow-ups):

Introduce a bundling step for server code to lock down runtime dependencies.

Improve zero-downtime deployment strategy (e.g., versioned image + swap or blue/green).

Add explicit validation of required .env variables before startup rather than warning only.

Deliverable:
A commit or set of commits that:

Removes unintended runtime dependency on vite (or temporarily patches it with clear annotation).

Ensures health endpoints are consistent.

Fixes the failing CI job so the deployment pipeline passes.

Updates documentation with the problem explanation, the fix, and instructions to avoid it in future.

(Optional) Opens a follow-up issue if any technical debt was introduced as a short-term workaround.